package opa

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io/ioutil"
	"os"

	"github.com/open-policy-agent/opa/rego"
	arngin "github.com/sudo-suhas/play-arngin"
)

// RegoEngine implements the arngin.Engine interface using rego.
type RegoEngine struct {
	pq rego.PreparedEvalQuery
	ok bool
}

const (
	query = "data.arngin.matched_addons"
	// File paths
	rulesFP = "./engine/opa/rules.rego"
	matchFP = "./engine/opa/match.rego"
)

// NewRegoEngine creates an instance of the RegoEngine. If the
// rules.rego file is not present, the initialisation of prepared query
// is deferred to LoadRules.
func NewRegoEngine(ctx context.Context) (arngin.Engine, error) {
	// Check if the rules.rego file exists
	if _, err := os.Stat(rulesFP); err != nil {
		if os.IsNotExist(err) {
			// The rules file does not exist and we can't create a rego
			// instance. So return the engine without initialising rego with the
			// hope that LoadRules would be called before RunQueries.
			return &RegoEngine{}, nil
		}

		return nil, fmt.Errorf("check rules.rego exists: %w", err)
	}

	r := rego.New(
		rego.Query(query),
		rego.Load([]string{rulesFP, matchFP}, nil), // Load rules, matchers into opa

		// If there are fields which may or may not be present, setup using
		// rego.EvalUnknowns([]string{"input.foo", "input.bar", "input.bar"}),
		// See https://godoc.org/github.com/open-policy-agent/opa/rego#example-Rego-PrepareForPartial
	)

	pq, err := r.PrepareForEval(ctx, rego.WithPartialEval())
	if err != nil {
		return nil, fmt.Errorf("prepare query for eval: %w", err)
	}

	return &RegoEngine{pq: pq, ok: true}, nil
}

var rulesHeader = []byte(`package arngin
# Rules generated by invoking 'arngin load --engine opa'

# When the number of rules are less, some attributes might never be specified
# across all rules. This would result in an error when trying to evaluate the
# input against our matchers. To avoid the error, initialise an empty rule to
# help setup the datatypes for each attribute.
rules = {
	"": {"sources": set(), "destinations": set(), "boardingPts": set(), "droppingPts": set(), "boardingTime": [0, 0], "droppingTime": [0, 0], "seatCount": { "op": "eq", "value": 0 }, "busOperators": set(), "duration": { "op": "eq", "value": 0 }, "appversion": { "op": "eq", "value": 0 }, "channels": set(), "addonIDs": []},
`)

func (re *RegoEngine) LoadRules(ctx context.Context, rules []arngin.AddonRule) error {
	buf := bytes.NewBuffer(rulesHeader)
	for i, r := range rules {
		if i != 0 {
			buf.WriteRune(',')
			buf.WriteRune('\n')
		}

		buf.WriteString("\t\"" + r.ID.String() + `": `)
		buf.Write(toOPARule(r))
	}
	buf.WriteRune('\n')
	buf.WriteRune('}')

	// Write the rules into the file so that future executions use it.
	// LoadRules is optional if the file is present.
	{
		if err := ioutil.WriteFile(rulesFP, buf.Bytes(), 0644); err != nil {
			return fmt.Errorf("wrte rules.rego file: %w", err)
		}
	}

	// Create a new instance of rego and prepared query with the rules we just
	// got.
	{
		r := rego.New(
			rego.Query(query),
			rego.Module("rules.rego", buf.String()),
			rego.Load([]string{rulesFP, matchFP}, nil), // Load rules, matchers into opa
		)

		pq, err := r.PrepareForEval(ctx, rego.WithPartialEval())
		if err != nil {
			return fmt.Errorf("prepare query for eval: %w", err)
		}

		re.pq = pq
		re.ok = true
	}

	return nil
}

func (re *RegoEngine) RunQuery(ctx context.Context, q arngin.AddonsQ) ([]string, error) {
	if !re.ok {
		return nil, errors.New("not initialised")
	}

	rs, err := re.pq.Eval(ctx, rego.EvalInput(q))
	if err != nil {
		return nil, fmt.Errorf("eval query for input: %w", err)
	}

	if len(rs) == 0 || len(rs[0].Expressions) == 0 {
		return nil, nil
	}

	vals, ok := rs[0].Expressions[0].Value.([]interface{})
	if !ok {
		return nil, fmt.Errorf("unexpected expression value type %T", rs[0].Expressions[0].Value)
	}

	addons := make([]string, len(vals))
	for i, v := range vals {
		s, ok := v.(string)
		if !ok {
			return nil, fmt.Errorf("unexpected expression value item type %T", v)
		}

		addons[i] = s
	}

	return addons, nil
}
